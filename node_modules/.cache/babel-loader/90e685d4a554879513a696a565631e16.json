{"ast":null,"code":"/**\n * Binary (exe, images and so, etc.)\n *\n * Note:\n *   This function is not considered for Unicode\n */\nfunction isBINARY(data) {\n  var i = 0;\n  var len = data && data.length;\n  var c;\n\n  for (; i < len; i++) {\n    c = data[i];\n\n    if (c > 0xFF) {\n      return false;\n    }\n\n    if (c >= 0x00 && c <= 0x07 || c === 0xFF) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isBINARY = isBINARY;\n/**\n * ASCII (ISO-646)\n */\n\nfunction isASCII(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b > 0xFF || b >= 0x80 && b <= 0xFF || b === 0x1B) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isASCII = isASCII;\n/**\n * ISO-2022-JP (JIS)\n *\n * RFC1468 Japanese Character Encoding for Internet Messages\n * RFC1554 ISO-2022-JP-2: Multilingual Extension of ISO-2022-JP\n * RFC2237 Japanese Character Encoding for Internet Messages\n */\n\nfunction isJIS(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b, esc1, esc2;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b > 0xFF || b >= 0x80 && b <= 0xFF) {\n      return false;\n    }\n\n    if (b === 0x1B) {\n      if (i + 2 >= len) {\n        return false;\n      }\n\n      esc1 = data[i + 1];\n      esc2 = data[i + 2];\n\n      if (esc1 === 0x24) {\n        if (esc2 === 0x28 || // JIS X 0208-1990/2000/2004\n        esc2 === 0x40 || // JIS X 0208-1978\n        esc2 === 0x42) {\n          // JIS X 0208-1983\n          return true;\n        }\n      } else if (esc1 === 0x26 && // JIS X 0208-1990\n      esc2 === 0x40) {\n        return true;\n      } else if (esc1 === 0x28) {\n        if (esc2 === 0x42 || // ASCII\n        esc2 === 0x49 || // JIS X 0201 Halfwidth Katakana\n        esc2 === 0x4A) {\n          // JIS X 0201-1976 Roman set\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nexports.isJIS = isJIS;\n/**\n * EUC-JP\n */\n\nfunction isEUCJP(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b < 0x80) {\n      continue;\n    }\n\n    if (b > 0xFF || b < 0x8E) {\n      return false;\n    }\n\n    if (b === 0x8E) {\n      if (i + 1 >= len) {\n        return false;\n      }\n\n      b = data[++i];\n\n      if (b < 0xA1 || 0xDF < b) {\n        return false;\n      }\n    } else if (b === 0x8F) {\n      if (i + 2 >= len) {\n        return false;\n      }\n\n      b = data[++i];\n\n      if (b < 0xA2 || 0xED < b) {\n        return false;\n      }\n\n      b = data[++i];\n\n      if (b < 0xA1 || 0xFE < b) {\n        return false;\n      }\n    } else if (0xA1 <= b && b <= 0xFE) {\n      if (i + 1 >= len) {\n        return false;\n      }\n\n      b = data[++i];\n\n      if (b < 0xA1 || 0xFE < b) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isEUCJP = isEUCJP;\n/**\n * Shift-JIS (SJIS)\n */\n\nfunction isSJIS(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  while (i < len && data[i] > 0x80) {\n    if (data[i++] > 0xFF) {\n      return false;\n    }\n  }\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b <= 0x80 || 0xA1 <= b && b <= 0xDF) {\n      continue;\n    }\n\n    if (b === 0xA0 || b > 0xEF || i + 1 >= len) {\n      return false;\n    }\n\n    b = data[++i];\n\n    if (b < 0x40 || b === 0x7F || b > 0xFC) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isSJIS = isSJIS;\n/**\n * UTF-8\n */\n\nfunction isUTF8(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  for (; i < len; i++) {\n    b = data[i];\n\n    if (b > 0xFF) {\n      return false;\n    }\n\n    if (b === 0x09 || b === 0x0A || b === 0x0D || b >= 0x20 && b <= 0x7E) {\n      continue;\n    }\n\n    if (b >= 0xC2 && b <= 0xDF) {\n      if (i + 1 >= len || data[i + 1] < 0x80 || data[i + 1] > 0xBF) {\n        return false;\n      }\n\n      i++;\n    } else if (b === 0xE0) {\n      if (i + 2 >= len || data[i + 1] < 0xA0 || data[i + 1] > 0xBF || data[i + 2] < 0x80 || data[i + 2] > 0xBF) {\n        return false;\n      }\n\n      i += 2;\n    } else if (b >= 0xE1 && b <= 0xEC || b === 0xEE || b === 0xEF) {\n      if (i + 2 >= len || data[i + 1] < 0x80 || data[i + 1] > 0xBF || data[i + 2] < 0x80 || data[i + 2] > 0xBF) {\n        return false;\n      }\n\n      i += 2;\n    } else if (b === 0xED) {\n      if (i + 2 >= len || data[i + 1] < 0x80 || data[i + 1] > 0x9F || data[i + 2] < 0x80 || data[i + 2] > 0xBF) {\n        return false;\n      }\n\n      i += 2;\n    } else if (b === 0xF0) {\n      if (i + 3 >= len || data[i + 1] < 0x90 || data[i + 1] > 0xBF || data[i + 2] < 0x80 || data[i + 2] > 0xBF || data[i + 3] < 0x80 || data[i + 3] > 0xBF) {\n        return false;\n      }\n\n      i += 3;\n    } else if (b >= 0xF1 && b <= 0xF3) {\n      if (i + 3 >= len || data[i + 1] < 0x80 || data[i + 1] > 0xBF || data[i + 2] < 0x80 || data[i + 2] > 0xBF || data[i + 3] < 0x80 || data[i + 3] > 0xBF) {\n        return false;\n      }\n\n      i += 3;\n    } else if (b === 0xF4) {\n      if (i + 3 >= len || data[i + 1] < 0x80 || data[i + 1] > 0x8F || data[i + 2] < 0x80 || data[i + 2] > 0xBF || data[i + 3] < 0x80 || data[i + 3] > 0xBF) {\n        return false;\n      }\n\n      i += 3;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isUTF8 = isUTF8;\n/**\n * UTF-16 (LE or BE)\n *\n * RFC2781: UTF-16, an encoding of ISO 10646\n *\n * @link http://www.ietf.org/rfc/rfc2781.txt\n */\n\nfunction isUTF16(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2, next, prev;\n\n  if (len < 2) {\n    if (data[0] > 0xFF) {\n      return false;\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n\n    if (b1 === 0xFF && // BOM (little-endian)\n    b2 === 0xFE) {\n      return true;\n    }\n\n    if (b1 === 0xFE && // BOM (big-endian)\n    b2 === 0xFF) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false; // Non ASCII\n    }\n\n    next = data[pos + 1]; // BE\n\n    if (next !== void 0 && next > 0x00 && next < 0x80) {\n      return true;\n    }\n\n    prev = data[pos - 1]; // LE\n\n    if (prev !== void 0 && prev > 0x00 && prev < 0x80) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isUTF16 = isUTF16;\n/**\n * UTF-16BE (big-endian)\n *\n * RFC 2781 4.3 Interpreting text labelled as UTF-16\n * Text labelled \"UTF-16BE\" can always be interpreted as being big-endian\n *  when BOM does not founds (SHOULD)\n *\n * @link http://www.ietf.org/rfc/rfc2781.txt\n */\n\nfunction isUTF16BE(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2;\n\n  if (len < 2) {\n    if (data[0] > 0xFF) {\n      return false;\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n\n    if (b1 === 0xFE && // BOM\n    b2 === 0xFF) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false; // Non ASCII\n    }\n\n    if (pos % 2 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isUTF16BE = isUTF16BE;\n/**\n * UTF-16LE (little-endian)\n */\n\nfunction isUTF16LE(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2;\n\n  if (len < 2) {\n    if (data[0] > 0xFF) {\n      return false;\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n\n    if (b1 === 0xFF && // BOM\n    b2 === 0xFE) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false; // Non ASCII\n    }\n\n    if (pos % 2 !== 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.isUTF16LE = isUTF16LE;\n/**\n * UTF-32\n *\n * Unicode 3.2.0: Unicode Standard Annex #19\n *\n * @link http://www.iana.org/assignments/charset-reg/UTF-32\n * @link http://www.unicode.org/reports/tr19/tr19-9.html\n */\n\nfunction isUTF32(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2, b3, b4;\n  var next, prev;\n\n  if (len < 4) {\n    for (; i < len; i++) {\n      if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n    b3 = data[2];\n    b4 = data[3];\n\n    if (b1 === 0x00 && b2 === 0x00 && // BOM (big-endian)\n    b3 === 0xFE && b4 === 0xFF) {\n      return true;\n    }\n\n    if (b1 === 0xFF && b2 === 0xFE && // BOM (little-endian)\n    b3 === 0x00 && b4 === 0x00) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false;\n    } // The byte order should be the big-endian when BOM is not detected.\n\n\n    next = data[pos + 3];\n\n    if (next !== void 0 && next > 0x00 && next <= 0x7F) {\n      // big-endian\n      return data[pos + 2] === 0x00 && data[pos + 1] === 0x00;\n    }\n\n    prev = data[pos - 1];\n\n    if (prev !== void 0 && prev > 0x00 && prev <= 0x7F) {\n      // little-endian\n      return data[pos + 1] === 0x00 && data[pos + 2] === 0x00;\n    }\n  }\n\n  return false;\n}\n\nexports.isUTF32 = isUTF32;\n/**\n * JavaScript Unicode array\n */\n\nfunction isUNICODE(data) {\n  var i = 0;\n  var len = data && data.length;\n  var c;\n\n  for (; i < len; i++) {\n    c = data[i];\n\n    if (c < 0 || c > 0x10FFFF) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isUNICODE = isUNICODE;","map":{"version":3,"sources":["/home/hiro/PokeChart/node_modules/encoding-japanese/src/encoding-detect.js"],"names":["isBINARY","data","i","len","length","c","exports","isASCII","b","isJIS","esc1","esc2","isEUCJP","isSJIS","isUTF8","isUTF16","pos","b1","b2","next","prev","isUTF16BE","isUTF16LE","isUTF32","b3","b4","isUNICODE"],"mappings":"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","sourcesContent":["/**\n * Binary (exe, images and so, etc.)\n *\n * Note:\n *   This function is not considered for Unicode\n */\nfunction isBINARY(data) {\n  var i = 0;\n  var len = data && data.length;\n  var c;\n\n  for (; i < len; i++) {\n    c = data[i];\n    if (c > 0xFF) {\n      return false;\n    }\n\n    if ((c >= 0x00 && c <= 0x07) || c === 0xFF) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexports.isBINARY = isBINARY;\n\n/**\n * ASCII (ISO-646)\n */\nfunction isASCII(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  for (; i < len; i++) {\n    b = data[i];\n    if (b > 0xFF ||\n        (b >= 0x80 && b <= 0xFF) ||\n        b === 0x1B) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexports.isASCII = isASCII;\n\n/**\n * ISO-2022-JP (JIS)\n *\n * RFC1468 Japanese Character Encoding for Internet Messages\n * RFC1554 ISO-2022-JP-2: Multilingual Extension of ISO-2022-JP\n * RFC2237 Japanese Character Encoding for Internet Messages\n */\nfunction isJIS(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b, esc1, esc2;\n\n  for (; i < len; i++) {\n    b = data[i];\n    if (b > 0xFF || (b >= 0x80 && b <= 0xFF)) {\n      return false;\n    }\n\n    if (b === 0x1B) {\n      if (i + 2 >= len) {\n        return false;\n      }\n\n      esc1 = data[i + 1];\n      esc2 = data[i + 2];\n      if (esc1 === 0x24) {\n        if (esc2 === 0x28 ||  // JIS X 0208-1990/2000/2004\n            esc2 === 0x40 ||  // JIS X 0208-1978\n            esc2 === 0x42) {  // JIS X 0208-1983\n          return true;\n        }\n      } else if (esc1 === 0x26 && // JIS X 0208-1990\n                 esc2 === 0x40) {\n        return true;\n      } else if (esc1 === 0x28) {\n        if (esc2 === 0x42 || // ASCII\n            esc2 === 0x49 || // JIS X 0201 Halfwidth Katakana\n            esc2 === 0x4A) { // JIS X 0201-1976 Roman set\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\nexports.isJIS = isJIS;\n\n/**\n * EUC-JP\n */\nfunction isEUCJP(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  for (; i < len; i++) {\n    b = data[i];\n    if (b < 0x80) {\n      continue;\n    }\n\n    if (b > 0xFF || b < 0x8E) {\n      return false;\n    }\n\n    if (b === 0x8E) {\n      if (i + 1 >= len) {\n        return false;\n      }\n\n      b = data[++i];\n      if (b < 0xA1 || 0xDF < b) {\n        return false;\n      }\n    } else if (b === 0x8F) {\n      if (i + 2 >= len) {\n        return false;\n      }\n\n      b = data[++i];\n      if (b < 0xA2 || 0xED < b) {\n        return false;\n      }\n\n      b = data[++i];\n      if (b < 0xA1 || 0xFE < b) {\n        return false;\n      }\n    } else if (0xA1 <= b && b <= 0xFE) {\n      if (i + 1 >= len) {\n        return false;\n      }\n\n      b = data[++i];\n      if (b < 0xA1 || 0xFE < b) {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexports.isEUCJP = isEUCJP;\n\n/**\n * Shift-JIS (SJIS)\n */\nfunction isSJIS(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  while (i < len && data[i] > 0x80) {\n    if (data[i++] > 0xFF) {\n      return false;\n    }\n  }\n\n  for (; i < len; i++) {\n    b = data[i];\n    if (b <= 0x80 ||\n        (0xA1 <= b && b <= 0xDF)) {\n      continue;\n    }\n\n    if (b === 0xA0 || b > 0xEF || i + 1 >= len) {\n      return false;\n    }\n\n    b = data[++i];\n    if (b < 0x40 || b === 0x7F || b > 0xFC) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexports.isSJIS = isSJIS;\n\n/**\n * UTF-8\n */\nfunction isUTF8(data) {\n  var i = 0;\n  var len = data && data.length;\n  var b;\n\n  for (; i < len; i++) {\n    b = data[i];\n    if (b > 0xFF) {\n      return false;\n    }\n\n    if (b === 0x09 || b === 0x0A || b === 0x0D ||\n        (b >= 0x20 && b <= 0x7E)) {\n      continue;\n    }\n\n    if (b >= 0xC2 && b <= 0xDF) {\n      if (i + 1 >= len || data[i + 1] < 0x80 || data[i + 1] > 0xBF) {\n        return false;\n      }\n      i++;\n    } else if (b === 0xE0) {\n      if (i + 2 >= len ||\n          data[i + 1] < 0xA0 || data[i + 1] > 0xBF ||\n          data[i + 2] < 0x80 || data[i + 2] > 0xBF) {\n        return false;\n      }\n      i += 2;\n    } else if ((b >= 0xE1 && b <= 0xEC) ||\n                b === 0xEE || b === 0xEF) {\n      if (i + 2 >= len ||\n          data[i + 1] < 0x80 || data[i + 1] > 0xBF ||\n          data[i + 2] < 0x80 || data[i + 2] > 0xBF) {\n        return false;\n      }\n      i += 2;\n    } else if (b === 0xED) {\n      if (i + 2 >= len ||\n          data[i + 1] < 0x80 || data[i + 1] > 0x9F ||\n          data[i + 2] < 0x80 || data[i + 2] > 0xBF) {\n        return false;\n      }\n      i += 2;\n    } else if (b === 0xF0) {\n      if (i + 3 >= len ||\n          data[i + 1] < 0x90 || data[i + 1] > 0xBF ||\n          data[i + 2] < 0x80 || data[i + 2] > 0xBF ||\n          data[i + 3] < 0x80 || data[i + 3] > 0xBF) {\n        return false;\n      }\n      i += 3;\n    } else if (b >= 0xF1 && b <= 0xF3) {\n      if (i + 3 >= len ||\n          data[i + 1] < 0x80 || data[i + 1] > 0xBF ||\n          data[i + 2] < 0x80 || data[i + 2] > 0xBF ||\n          data[i + 3] < 0x80 || data[i + 3] > 0xBF) {\n        return false;\n      }\n      i += 3;\n    } else if (b === 0xF4) {\n      if (i + 3 >= len ||\n          data[i + 1] < 0x80 || data[i + 1] > 0x8F ||\n          data[i + 2] < 0x80 || data[i + 2] > 0xBF ||\n          data[i + 3] < 0x80 || data[i + 3] > 0xBF) {\n        return false;\n      }\n      i += 3;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\nexports.isUTF8 = isUTF8;\n\n/**\n * UTF-16 (LE or BE)\n *\n * RFC2781: UTF-16, an encoding of ISO 10646\n *\n * @link http://www.ietf.org/rfc/rfc2781.txt\n */\nfunction isUTF16(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2, next, prev;\n\n  if (len < 2) {\n    if (data[0] > 0xFF) {\n      return false;\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n    if (b1 === 0xFF && // BOM (little-endian)\n        b2 === 0xFE) {\n      return true;\n    }\n    if (b1 === 0xFE && // BOM (big-endian)\n        b2 === 0xFF) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false; // Non ASCII\n    }\n\n    next = data[pos + 1]; // BE\n    if (next !== void 0 && next > 0x00 && next < 0x80) {\n      return true;\n    }\n\n    prev = data[pos - 1]; // LE\n    if (prev !== void 0 && prev > 0x00 && prev < 0x80) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexports.isUTF16 = isUTF16;\n\n/**\n * UTF-16BE (big-endian)\n *\n * RFC 2781 4.3 Interpreting text labelled as UTF-16\n * Text labelled \"UTF-16BE\" can always be interpreted as being big-endian\n *  when BOM does not founds (SHOULD)\n *\n * @link http://www.ietf.org/rfc/rfc2781.txt\n */\nfunction isUTF16BE(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2;\n\n  if (len < 2) {\n    if (data[0] > 0xFF) {\n      return false;\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n    if (b1 === 0xFE && // BOM\n        b2 === 0xFF) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false; // Non ASCII\n    }\n\n    if (pos % 2 === 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexports.isUTF16BE = isUTF16BE;\n\n/**\n * UTF-16LE (little-endian)\n */\nfunction isUTF16LE(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2;\n\n  if (len < 2) {\n    if (data[0] > 0xFF) {\n      return false;\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n    if (b1 === 0xFF && // BOM\n        b2 === 0xFE) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false; // Non ASCII\n    }\n\n    if (pos % 2 !== 0) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexports.isUTF16LE = isUTF16LE;\n\n/**\n * UTF-32\n *\n * Unicode 3.2.0: Unicode Standard Annex #19\n *\n * @link http://www.iana.org/assignments/charset-reg/UTF-32\n * @link http://www.unicode.org/reports/tr19/tr19-9.html\n */\nfunction isUTF32(data) {\n  var i = 0;\n  var len = data && data.length;\n  var pos = null;\n  var b1, b2, b3, b4;\n  var next, prev;\n\n  if (len < 4) {\n    for (; i < len; i++) {\n      if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n  } else {\n    b1 = data[0];\n    b2 = data[1];\n    b3 = data[2];\n    b4 = data[3];\n    if (b1 === 0x00 && b2 === 0x00 && // BOM (big-endian)\n        b3 === 0xFE && b4 === 0xFF) {\n      return true;\n    }\n\n    if (b1 === 0xFF && b2 === 0xFE && // BOM (little-endian)\n        b3 === 0x00 && b4 === 0x00) {\n      return true;\n    }\n\n    for (; i < len; i++) {\n      if (data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x00) {\n        pos = i;\n        break;\n      } else if (data[i] > 0xFF) {\n        return false;\n      }\n    }\n\n    if (pos === null) {\n      return false;\n    }\n\n    // The byte order should be the big-endian when BOM is not detected.\n    next = data[pos + 3];\n    if (next !== void 0 && next > 0x00 && next <= 0x7F) {\n      // big-endian\n      return data[pos + 2] === 0x00 && data[pos + 1] === 0x00;\n    }\n\n    prev = data[pos - 1];\n    if (prev !== void 0 && prev > 0x00 && prev <= 0x7F) {\n      // little-endian\n      return data[pos + 1] === 0x00 && data[pos + 2] === 0x00;\n    }\n  }\n\n  return false;\n}\nexports.isUTF32 = isUTF32;\n\n/**\n * JavaScript Unicode array\n */\nfunction isUNICODE(data) {\n  var i = 0;\n  var len = data && data.length;\n  var c;\n\n  for (; i < len; i++) {\n    c = data[i];\n    if (c < 0 || c > 0x10FFFF) {\n      return false;\n    }\n  }\n\n  return true;\n}\nexports.isUNICODE = isUNICODE;\n"]},"metadata":{},"sourceType":"script"}